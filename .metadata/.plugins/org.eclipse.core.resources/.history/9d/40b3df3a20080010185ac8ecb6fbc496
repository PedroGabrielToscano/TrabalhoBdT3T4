package services;

import database.PostgresDatabaseConnection;
import models.Fornecedor;
import models.EmailFornecedor;
import models.FoneFornecedor;

import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class FornecedorService {

    /**
     * Retorna todos os fornecedores cadastrados no banco,
     * juntamente com seus e-mails e telefones (se desejar).
     */
    public List<Fornecedor> listarFornecedoresComContatos() {
        List<Fornecedor> lista = new ArrayList<>();
        String sqlFornecedor = "SELECT f.idfornecedor, f.cnpj, f.nome, f.saldoapagar "
                             + "FROM fornecedor f";

        try (Connection conn = PostgresDatabaseConnection.getConnection();
             Statement st = conn.createStatement();
             ResultSet rs = st.executeQuery(sqlFornecedor)) {

            while (rs.next()) {
                Fornecedor fornecedor = new Fornecedor();
                fornecedor.setIdFornecedor(rs.getInt("idfornecedor"));
                fornecedor.setCnpj(rs.getString("cnpj"));
                fornecedor.setNome(rs.getString("nome"));
                fornecedor.setSaldoAPagar(rs.getDouble("saldoapagar"));
                
                // Carrega e-mails do fornecedor
                fornecedor.setListaEmails(listarEmailsFornecedor(fornecedor.getIdfornecedor(), conn));
                
                // Carrega fones do fornecedor
                fornecedor.setListaFones(listarFonesFornecedor(fornecedor.getIdFornecedor(), conn));
                
                lista.add(fornecedor);
            }

        } catch (SQLException e) {
            e.printStackTrace();
        }
        return lista;
    }

    /**
     * Lista todos os e-mails de um determinado fornecedor.
     * Usamos a mesma conexão para otimizar.
     */
    private List<EmailFornecedor> listarEmailsFornecedor(int idFornecedor, Connection conn) {
        List<EmailFornecedor> listaEmails = new ArrayList<>();
        String sql = "SELECT idemail, emailfornecedor FROM emailfornecedor WHERE idfornecedor = ?";

        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, idFornecedor);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {
                EmailFornecedor email = new EmailFornecedor();
                email.setIdEmail(rs.getInt("idemail"));
                email.setEmailFornecedor(rs.getString("emailfornecedor"));
                listaEmails.add(email);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return listaEmails;
    }

    /**
     * Lista todos os telefones de um determinado fornecedor.
     */
    private List<FoneFornecedor> listarFonesFornecedor(int idFornecedor, Connection conn) {
        List<FoneFornecedor> listaFones = new ArrayList<>();
        String sql = "SELECT ff.idfone, ff.nrofonefornecedor, "
                   + "       ddi.ddi, ddd.ddd "
                   + "FROM fonefornecedor ff "
                   + "JOIN ddifornecedor ddi ON ff.id_ddifornecedor = ddi.id_ddifornecedor "
                   + "JOIN dddfornecedor ddd ON ff.id_dddfornecedor = ddd.id_dddfornecedor "
                   + "WHERE ff.idfornecedor = ?";

        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, idFornecedor);
            ResultSet rs = ps.executeQuery();

            while (rs.next()) {
                FoneFornecedor fone = new FoneFornecedor();
                fone.setIdFone(rs.getInt("idfone"));
                // Concatenando DDI + DDD + Número para formar o telefone completo
                String ddi = rs.getString("ddi");
                String ddd = rs.getString("ddd");
                String numero = rs.getString("nrofonefornecedor");
                fone.setNroFoneFornecedor(ddi + " (" + ddd + ") " + numero);
                
                listaFones.add(fone);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        }

        return listaFones;
    }
    
    /**
     * Cadastra um novo fornecedor no banco de dados.
     * O SQL utiliza a função ROW para inserir o tipo composto "enderecoespecifico".
     */
    public void cadastrarFornecedor(Fornecedor fornecedor) throws SQLException {
        String sql = "INSERT INTO fornecedor (idfornecedor, cnpj, nome, idendereco, saldoapagar, enderecoespecifico) " +
                     "VALUES (?, ?, ?, ?, ?, ROW(?, ?))";
                     
        try (Connection conn = PostgresDatabaseConnection.getConnection();
             PreparedStatement ps = conn.prepareStatement(sql)) {

            ps.setInt(1, fornecedor.getIdFornecedor());
            ps.setString(2, fornecedor.getCnpj());
            ps.setString(3, fornecedor.getNome());
            // Supõe-se que o objeto Endereco já esteja instanciado no fornecedor
            ps.setInt(4, fornecedor.getEndereco().getIdEndereco());
            ps.setDouble(5, fornecedor.getSaldoAPagar());
            // Valores do tipo composto EnderecoEspecifico: numeroEnd e complemento
            ps.setInt(6, fornecedor.getEnderecoEspecifico().getNumeroEnd());
            ps.setString(7, fornecedor.getEnderecoEspecifico().getComplemento());

            ps.executeUpdate();
        }
    }
}
